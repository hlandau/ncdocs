Namecoin: Lightweight Resolution Roadmap
----------------------------------------

Currently, the only options for people wanting to resolve Namecoin names are to deploy a full node or to trust a full node operated by another person. However, there are viable means for the deployment of trustless lightweight resolvers which require only a minimal data set to be stored locally.

By using SPV, clients need only store headers for the last 36,000 blocks, which takes just a few megabytes. The Namecoin wire protocol must be extended so that nodes can query for transactions by name. Responses can use Merkle branches to prove that the transaction was included in a block which the SPV client is aware of. There are various threats which this does not counter; for example, a malicious peer could respond with an older (but non-expired) transaction in response to a query.

However, further reinforcement can increase security further. A cryptographic data structure such as a Merkle tree can be used to concisely represent the identity of a set, such as the set of all names, and a concise proof of inclusion (i.e. a Merkle branch) can be generated that proves the inclusion of a given item in that set. That proof of inclusion can be verified using only the root hash of the data structure.

By having miners include this root hash in the coinbase transaction of every block, the identity of the set of all current names is attested to continously throughout the mining process. Once all miners adopt this modification to Namecoin, it can become a network rule; the inclusion and correctness of the root hash can be enforced by all miners.

Lightweight clients can then keep track of the current root hash (more accurately, the root hash in the block which is N blocks deep, for some value of N). Peers can generate concise proofs of inclusion in response to client queries. Thus, when a client queries for a name transaction by name, a peer responds not only with the name transaction and proof of inclusion in a given block, but also with a proof of inclusion of the name transaction in the set of current names as attested to by the root hash.

This constitutes a significant reinforcement to SPV-only clients, as it prevents peers from returning anything but current name data. This mode is referred to as 'SPV36+UTXO CB' (short for SPV 36,000 blocks plus unspent transaction output coinbase attestation; since name operations are marked spent when they expire, the fact of a name transaction being unspent is proof that it is current).

However, deployment of this mode is made difficult by a number of unsolved problems in relation to the formulation of the cryptographic data structure used for representing the UTXO set. Similar UTXO coinbase attestation proposals have been made for Bitcoin, so some existing work such as the Authenticated Prefix Trees BIP may be applicable.

The most fundamental of these issues is that since new transactions occur continously, it is important that miners be able to efficiently compute updates to the UTXO set. In other words, it must not be necessary for the entire cryptographic data structure to be recomputed when a new transaction is added to the set. Of course, any solution must preserve the ability to concisely represent the identity of the set and the ability to generate concise proofs of inclusion.

Another issue is that the varying block depth thresholds used by such SPV-based clients may necessitate that peers be able to generate proofs of inclusion for the UTXO set which was current as of any given block. In the absence of the miracle formulationof a differential cryptographic data structure which can preserve all of the above properties while concisely representing a large number of related sets, this would require peers to keep the UTXO sets current at all blocks in memory separately. Since this is obviously infeasible, it is likely that this problem will be solved by requiring all clients to use a SPV depth threshold of 12. This is not a significant issue, as if an attacker is able to undo 12 blocks, many of the security premises of Namecoin (and indeed Bitcoin) would be broken anyway.

The final security issue to be challenged is authenticated denial of existence. This can be solved using coinbase attestation of another set, the set of all adjacent keys, in sorted order. This tree must be formulated such that proofs of adjacency can be generated. This will allow peers to prove that no unexpired keys exist which are lexicographically between two given names. This directly comparable DNSSEC's method of authenticated denial of existence by the same method; by a sorted sequence of signed records stating that no names exist between two given names. This mode is referred to as SPV36+UTXO CB+NX CB. Since denial of existence is considered a lesser threat, it has the lowest priority of these proposals, but should be implemented eventually.

Hopefully this post has illustrated how both secure and lightweight resolution of Namecoin is not only possible but can become practical.
